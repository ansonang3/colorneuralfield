#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Jan 27 15:53:58 2018

Last modified: Fri Dec 14 2018

@author: Anna Song

Companion script for:
    - main_pytorch.py
    - main_HSL_pytorch_2D.py
in order to visualize things.

In particular, it allows to visualize the Wilson Cowan simulation, evolution of the activities
and compare the final activities c \to a(r_0,c) generated by 2 (or 3) different
configurations.

"""

import numpy as np
import matplotlib.pyplot as plt
import colorsys
from scipy.signal import fftconvolve


from settings import date
if date in [2004,2008] :
    from settings import purple, lime, test, white, col_diff
    from settings import nb,dr

from settings import R,LC,Nc,Nx,dx,dc, space_abs, color_abs, extended_abs, extended_color_abs
from settings import spatial, spatial_index,color, create_images


def F(x,gamma) :
    return 1/(1+np.exp(-gamma*x))

xx,yy = np.mgrid[-R:R:(2*Nx+1)*1j,-R:R:(2*Nx+1)*1j]
D,DD = np.mgrid[-LC:LC:(2*Nc+1)*1j,-LC:LC:(2*Nc+1)*1j]


def create_annulus_image(config_array,show_C = False) :
    from settings import dr_ann
    Y,X = np.mgrid[0:2*Nx+1, 0:2*Nx+1]
    X_abs = spatial(X)
    Y_abs = spatial(Y)
    test,near,farther = config_array
    C = np.zeros((2*Nx+1,2*Nx+1))
    for i in range(2*nb+1) :
        r = R - i*dr_ann
        annulus = ((r-dr_ann)**2 < X_abs**2 + Y_abs**2)*(X_abs**2 + Y_abs**2 <= r**2)
        if i == nb :
            col = test
        elif (i-nb)%2 == 0 :
            col = farther
        else :
            col = near
        C[annulus] = col
    
    if show_C :
        imC = plt.imshow(C,cmap='RdBu',extent = [-1,1,-1,1], vmin = -1, vmax = 1 )
        plt.colorbar(imC, orientation='vertical')
        plt.show()
    return C

def plotmap(f,g) :
    cxx,cyy = np.mgrid[-LC:LC:(2*Nc+1)*1j,-LC:LC:(2*Nc+1)*1j]
    xxx,yyy = np.mgrid[slice(-7*R,7*R+dx,dx),slice(-7*R,7*R+dx,dx)]

    fmap = f(cyy,cxx)
    gmap = g(xx,yy)
#    gmap2 = g(xxx,yyy)
    
    plt.figure()
    plt.subplot(2,2,1)
    plt.colorbar(plt.imshow(gmap,cmap = 'RdBu',vmin = -max(abs(gmap.min()),abs(gmap.max())), vmax = max(abs(gmap.min()),abs(gmap.max()))), orientation='vertical') # ticks ne marche pas : ticks = np.linspace(-1,1,2*Nc+1,endpoint = True)

    plt.subplot(2,2,2)
    plt.colorbar(plt.imshow(fmap,cmap = 'RdBu',vmin = -max(abs(fmap.min()),abs(fmap.max())), vmax = max(abs(fmap.min()),abs(fmap.max()))), orientation='vertical') # ticks ne marche pas : ticks = np.linspace(-1,1,2*Nc+1,endpoint = True)
    
    plt.subplot(2,2,3)
    plt.plot(space_abs,gmap[Nx])

    plt.subplot(2,2,4)
    plt.plot(color_abs,fmap[round(4/3*Nc)])
    plt.plot(color_abs,fmap[round(Nc)])
    
    plt.show()
    
#    ind = gmap2.shape[0]//2
#    plt.figure()
#    plt.title('global view of g')
#    plt.plot(gmap2[ind])
#    plt.show()

def Gauss(abscisse,sigma,mu = 1):
    gauss = lambda x : mu*np.exp(-(x**2)/(2*sigma**2))
    G = gauss(abscisse)
    return G

def show_maps(q,show_other = False) :
    '''plot the maps of g, f, g on R, h, sigmoid F,
    given a vector parameter q '''

    muf,nuf,alphaf,betaf,mug,nug,alphag,betag,muh,sigmah,gamma = q
    u = lambda c : muf*np.exp(-c**2/(2*alphaf**2))
    v = lambda c : nuf*np.exp(-c**2/(2*betaf**2))
    f = lambda cc,c : u(c-cc) - v(c+cc)
    gauss1 = lambda x : np.exp(-x**2/(2*alphag**2))
    gauss2 = lambda x : np.exp(-x**2/(2*betag**2))
    g = lambda x,y : mug*gauss1(x)*gauss1(y) - nug*gauss2(x)*gauss2(y)

    plotmap(f,g)
    
    if show_other :
        xxx,yyy = np.mgrid[slice(-3*R,3*R+dx,dx),slice(-3*R,3*R+dx,dx)]        

        gmap2 = g(xxx,yyy)
        ind = gmap2.shape[0]//2
        plt.figure()
        plt.plot(gmap2[ind])
        plt.show()
        plt.figure()
        plt.plot(Gauss(color_abs,sigma = sigmah, mu = muh))
        plt.show()
        F = lambda x : 1./(1+np.exp(-gamma*x)) #Sigmoid function
        plt.figure()
        plt.plot(F(np.linspace(-4,4,20)))
        plt.show()

if date in [2004,2008] :
    N = 39 # number of time iterations in evolution()
    
    def evolution(q,config_array,show = False,dt = 1,dr = dr,a_0 = None) :
        '''evolution() simulates the evolution of neural activities towards their respective limits (color sensations)
        and displays it for different points of interest, belonging in particular to
        different bands (corresponding to annuli before retinotopy).    
        This function is only used for date in [2004,2008].
        
        config_array parameterizes the input image.
        By default, the time step is dt = 1 (then, we perform a fixed point iteration).
        a_0 is the initial value. By default, it is constant equal to .5, but we can test on random initial values
        in order to check that the activities still converge to the same stationary point.
        '''
        global xx,yy,D,DD,C
        muf,nuf,alphaf,betaf,mug,nug,alphag,betag,muh,sigmah,gamma = q
        
        if a_0 is None :
            a = 1/2*np.ones((2*Nx+1,2*Nx+1,2*Nc+1))
        else :
            a = a_0
    
        u = lambda c : muf*np.exp(-c**2/(2*alphaf**2))
        v = lambda c : nuf*np.exp(-c**2/(2*betaf**2))
        gauss1 = lambda x : np.exp(-x**2/(2*alphag**2))
        gauss2 = lambda x : np.exp(-x**2/(2*betag**2))
        h = lambda x : muh*np.exp(-x**2/(2*sigmah**2))
        
        G1 = gauss1(extended_abs).reshape((4*Nx+1,1,1))
        G2 = gauss2(extended_abs).reshape((4*Nx+1,1,1))
        C1 = u(extended_color_abs).reshape((1,1,4*Nc+1))
        C2 = v(extended_color_abs).reshape((1,1,4*Nc+1))
        
        if show :
            f = lambda cc,c : u(c-cc) - v(c+cc)
            g = lambda x,y : mug*gauss1(x)*gauss1(y) - nug*gauss2(x)*gauss2(y)
            plotmap(f,g)
            
        C = create_images(config_array,show_C = False)
    
        Cdiff = color_abs[None,None,:] - C[:,:,None]
        H = h(Cdiff)
        
        aux_factor = dc*dx**2
    
        for n in range(N) :
            fu = fftconvolve(a,G1,'same')
            fu = fftconvolve(fu.transpose((1,0,2)),G1,'same').transpose((1,0,2))
            fv = fftconvolve(a,G2,'same')
            fv = fftconvolve(fv.transpose((1,0,2)),G2,'same').transpose((1,0,2))
            fw = mug*fu - nug*fv
            w = fftconvolve(fw,C1,'same') - np.flip(fftconvolve(fw,C2,'same'),2)
            w = aux_factor*w
            a = (1-dt)*a + dt*F(w + H,gamma)
                    
            if show == 1:
                print('unit iteration',n*dt)
                display(a,C,dr = dr,save = True,save_num = n)
                print("\nn = ",n)
                
        loc = spatial_index(R - (nb+0.5)*dr)
        return a[Nx,loc,:]
        
    def display(a,C,draw = True,dr = dr,save = False,save_num = 0) :
        colorax = [color(i) for i in range(2*Nc+1)]
        fig, ax = plt.subplots()
        for s in range(6) :
            ax.plot(colorax,a[Nx,spatial_index(R-(s+0.5)*dr)],color = list(colorsys.hsv_to_rgb(230/360,0.7,0.5+s/(2*5))))
        ax.plot(colorax,a[Nx,spatial_index(R-(nb+0.5)*dr)],color = 'r')
        plt.axis([-LC,LC,0,1])
        plt.show()

    def compare(q,config1,config2,config3 = np.zeros(0),show = False,dt = 1,dr = dr, save = False):
        ''' compare color sensations for 2 (or 3) configurations '''
        global color_abs
        muf,nuf,alphaf,betaf,mug,nug,alphag,betag,muh,sigmah,gamma = q
    
        a_test = evolution(q,config1,show = show,dt = dt,dr = dr)
        a_comp = evolution(q,config2,show = show,dt = dt,dr = dr)
        
        plt.plot(color_abs,a_test)
        plt.plot(color_abs,a_comp)
        if config3.any() :
            a_comp_pred = evolution(q,config3,show = show,dt = dt,dr = dr)
            plt.plot(color_abs,a_comp_pred)
            plt.legend(['a_test','a_comp','a_comp_pred'])
        else :
            plt.legend(['a_test','a_comp'])
        plt.axis([-LC,LC,0,1])
    
        string = 'purple/lime configuration, N = %.0f iterations' %N
        plt.title(string)
        if save :
            plt.savefig('MCCCCCcompare.pdf',dpi=100)
        plt.show()
        return a_test, a_comp
    

def write(q,letter = True) :
    if letter :
        print('f %.2f, %.2f, %.2f, %.2f, g %.2f, %.2f, %.2f, %.2f, h %.2f, %.2f, F %.2f' % tuple(q))
    else :
        print('%.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f' % tuple(q))

def show_W(q,r0,c0) :
    '''show_W returns the connectivity kernel w(r0,c0,r,c) where r0,c0 fixed
    typically (r0,c0) = (0,1) '''
    muf,nuf,alphaf,betaf,mug,nug,alphag,betag,muh,sigmah,gamma = q
    u = lambda c : muf*np.exp(-c**2/(2*alphaf**2))
    v = lambda c : nuf*np.exp(-c**2/(2*betaf**2))
    gauss1 = lambda x : np.exp(-x**2/(2*alphag**2))
    gauss2 = lambda x : np.exp(-x**2/(2*betag**2))
    g = lambda x,y : mug*gauss1(x)*gauss1(y) - nug*gauss2(x)*gauss2(y)
    G = g(r0[0] - xx, r0[1] - yy)
    F = u(c0 - color_abs) - v(c0 + color_abs)
    W = np.tensordot(G,F,axes = 0)
    return W # 3D

def show_H(q,config) :
    '''show_H returns the LGN input H = h(c - C(r)) for the cortical image C '''
    C = create_images(config) # size (2*Nx+1)^2
    Cdiff = C[:,:,None] - color_abs[None,None,:]
    muf,nuf,alphaf,betaf,mug,nug,alphag,betag,muh,sigmah,gamma = q
    h = lambda x : muh*np.exp(-x**2/(2*sigmah**2))
    H = h(Cdiff)
    return H # 3D


''' to visualize the evolution of neural activities independently from main_pytorch.py '''
run_test = 0

if __name__ == '__main__' and run_test :
    comp = 1.3 - col_diff # AZ
    comp = 1.6 - col_diff # PM
    config1 = np.array([test,purple,lime])
    config2 = np.array([comp,white,white])

    from initialization import q_MC
    q = q_MC
    a = evolution(q,config1,show = True, dt = 1)


